<!--
published: false
title: Lambda Calculus: Building little languages
category: [Programming, Languages, Lambda Calculus, IR]
excerpt: |
feature_text: |
  **I believe in the separation of Church and State **
feature_image: "/assets/imgs/koz3.JPG"
image: "/assets/imgs/koz3.JPG"
-->

# Lambda Calculus: Building little languages

In my work I have had several opportunities to build tooling for other developers.
Specifically these have been tools for assembling apps, programs and infrastructure using a high level language.

These have mostly been experimental, either exploring the benefits of different compiler architectures, approaches to optimisation or programming paradigms.

So, I've been stuck with a question:

> How do we build a programming language from the smallest number of the simplest parts possible?

Many approaches have been taken to building programming languages and compilers, and there are almost as many approaches to doing so.

## A small family tree of programming language models

My favourite class of approaches is to build a small core language and build everything on top of that. This has a few benefits that I hope to detail here.

## TODO: Finish

```rust
println!("TODO: Add example {:?}", 2*32);
```

